저 pdf파일이랑 소스코드 짠거는 https://github.com/yougtack/YT_Kim.github.io 여기다가 따로 올리겠습니다.



[3-6] 아래는 변수 num의 값보다 크면서도 가장 가까운 10의 배수에서 변수 num의 값을 뺀 나머지를 구하는 코드이다.
예를 들어, 24의 크면서도 가장 가까운 10의 배수는 30이 다. 19의 경우 20이고, 81의 경우 90이 된다.
30에서 24를 뺀 나머지는 6이기 때문에 변 수 num의 값이 24라면 6을 결과로 얻어야 한다.
(1)에 알맞은 코드를 넣으시오.

int num = 24;
System.out.println( /* (1) */ );
 
내가 문제를 이해한 것으로는 주어진 수의 일의자리 - 10 하면 될것 같았다. 그래서 처음엔 나누기 연산자로 시도를 하였다. num/10을 하니 값은 2가 나왔다. 
왜그런가 생각해보니 멍청하게 나머지 연산자가 아니라 나누기를 하고 앉아있던 것이다. 그래서 다시 num%10을 하니 이번엔 제대로 4가 나왔다. 이제 이걸 -10 하면 된다!
num%10 - 10을 하니 값이 -6이 나와서 당황 했지만 다시 바꾼뒤 제대로 된 값을 얻어냈다.


[3-7] 아래는 화씨(Fahrenheit)를 섭씨(Celcius)로 변환하는 코드이다. 
변환공식이 'C = 5/9 ×(F - 32)'라고 할 때, (1)에 알맞은 코드를 넣으시오.
단, 변환 결과값은 소수점 셋째자리에서 반올림해야한다.(Math.round()를 사용하지 않고 처리할 것)

int fahrenheit = 100;
float celcius = ( /* (1) */ );

System.out.println("Fahrenheit:"+fahrenheit);
System.out.println("Celcius:"+celcius);

문제의 전문용어가 많이 나와서 글씨 읽기가 힘들었다. 문제를 보니 소수점 셋째자리에서 반올림하라고 해서 한참 고민을 했다. 책의 나와 있는 거랑 비슷한게 있어서 
참고하였다. 먼저 5/9x(F-32)=37.77778어쩌구 저쩌구 한다. 여기서 100을 곱하면 3777.778이되고 반올림을 하기위해 0.5를 더학 나면 3778.278이 된다.
여기서 인트형으로 형변환 시켜주면 3778이 처음에 100곱해줬던 것을 나누기 100해주면 값은37.78이된다.


[3-8] 아래 코드의 문제점을 수정해서 실행결과와 같은 결과를 얻도록 하시오.

byte a = 10; 
byte b = 20;
byte c = a + b;

char ch = 'A'; 
ch = ch + 2;

float f = 3 / 2;
long l = 3000 * 3000 * 3000;

float f2 = 0.1f; 
double d = 0.1;
boolean result = d==f2;

[실행결과]
c=30
ch=C
f=1.5
l=27000000000
result=true


1.byte c = a + b 에서  a+b는 int형으로 계산이 되기 때문에 (byte)a+b로 바이트형으로 형변환 해줘야 한다.
2.ch + 2는 ch가 아스키코드 값으로 바뀐다음 + 2가 되기 때문에 값이 67로 나오게 된다. 하지만 우리가 원하는 출력형태는 C이므로 (char)ch+2처럼 형변환을 해줘야한다.
3.3/2도 int 타입으로 계산되기 때문에 두수중 아무데나 f를 붙여줘서 자동형변환이 되게 해줘야한다.
4.이것도 3000*3000*3000이 int로 계산되기 때문에 자동형변환이 되게 3개중 아무데나 L을 붙여 줘야한다.
5.더블형과 플룻형은 같은 숫자라도 값이 다르다 왜냐하면 더블형은 근사값이 존재하기 때문에 d==f2는 false이다 하지만 값은 true이기 때문에 (float)d==f2처럼 
형변환을 해줘야한다.

[3-9] 다음은 문자형 변수 ch가 영문자(대문자 또는 소문자)이거나 숫자일 때만 변수 b 의 값이 true가 되도록 하는 코드이다. 
(1)에 알맞은 코드를 넣으시오.

char ch = 'z';
boolean b = ( /* (1) */ );

~이거나 가 들어가니깐 논리연산자를 쓸것이라고 생각했다. 먼저 대문자 또는 소문자를 구별해줘야 하기 때문에 'a'<= ch && ch <= 'z' ||  'A' <= ch && ch <= 'Z'
를 해주었다. 그리고 숫자 일때도 true가 되어야 하기 때문에  '0' <= ch && ch <= '9' 도 추가해 주었다. 
'a'<= ch && ch <= 'z' || '0' <= ch && ch <= '9' || 'A' <= ch && ch <= 'Z' 조금 길어지긴 했지만 어떡게 해야 더 짧아 질지 생각이 안난다.

[3-10] 다음은 대문자를 소문자로 변경하는 코드인데, 문자 ch에 저장된 문자가 대문자 인 경우에만 소문자로 변경한다.
문자코드는 소문자가 대문자보다 32만큼 더 크다. 
예를 들어 'A‘의 코드는 65이고 ’a'의 코드는 97이다.
(1)~(2)에 알맞은 코드를 넣으시오.

char ch = 'A';
char lowerCase = ( /* (1) */ ) ? ( /* (2) */ ) : ch;

위에 문제와 비슷한것 같다. 그런데 이건 삼항 연산자 로 써야하는 느낌이 온다.. ?도 있고 :도 있고 해서.. 여기서 주의해야 할것은 아마도 대문자를 어떡게 소문자로 만드는
것이냐 인것 같다. 
('A' <= ch && ch <= 'Z')? (char)(ch+32): ch; 나는 이렇게 짯다.


